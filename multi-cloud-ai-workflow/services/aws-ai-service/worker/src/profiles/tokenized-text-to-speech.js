const util = require("util");
const AWS = require("aws-sdk");

const uuidv4 = require("uuid/v4");

const fs = require("fs");
const fsWriteFile = util.promisify(fs.writeFile);
const fsReadFile = util.promisify(fs.readFile);
const fsUnlink = util.promisify(fs.unlink);

const { ffmpeg } = require("../ffmpeg");

const S3 = new AWS.S3();
const S3GetObject = util.promisify(S3.getObject.bind(S3));
const S3CopyObject = util.promisify(S3.copyObject.bind(S3));
const S3DeleteObject = util.promisify(S3.deleteObject.bind(S3));
const S3PutObject = util.promisify(S3.putObject.bind(S3));

const Polly = new AWS.Polly();
const PollyStartSpeechSynthesisTask = util.promisify(Polly.startSpeechSynthesisTask.bind(Polly));

const { Logger, JobAssignment, Locator, AIJob } = require("mcma-core");
const { WorkerJobHelper } = require("mcma-worker");
const { DynamoDbTableProvider, getAwsV4ResourceManager } = require("mcma-aws");


async function tokenizedTextToSpeech(workerJobHelper) {
    const jobInput = workerJobHelper.getJobInput();
    const inputFile = jobInput.inputFile;
    const voiceId = jobInput.voiceId;
    const jobAssignmentId = workerJobHelper.getJobAssignmentId();

    Logger.debug("14. Generate SSML file for Polly from Tokenized translation");

    Logger.debug("14.1. get input text file from translation service stored in tempBucket (defined in job initiator in step 14");
    const s3Bucket = inputFile.awsS3Bucket;
    const s3Key = inputFile.awsS3Key;
    let s3Object;
    try {
        s3Object = await S3GetObject({
            Bucket: s3Bucket,
            Key: s3Key,
        });
    } catch (error) {
        throw new Error("Unable to read file in bucket '" + s3Bucket + "' with key '" + s3Key + "' due to error: " + error.message);
    }

    Logger.debug("14.2. extract text from file");
    const inputText = s3Object.Body.toString();
    console.log("translation:", inputText)

    Logger.debug("14.3. setup and call polly service to retrieve speechmarks per sentence");
    const params_sm = {
            OutputFormat: 'json',
            OutputS3BucketName: workerJobHelper.getRequest().getRequiredContextVariable("ServiceOutputBucket"),
            OutputS3KeyPrefix:'000-TextTokensSpeechMarksJob-' + jobAssignmentId.substring(jobAssignmentId.lastIndexOf("/") + 1),
            Text: inputText,
            SpeechMarkTypes: ["sentence"],
            VoiceId: voiceId,
            TextType: 'text'
        }
    const data = await PollyStartSpeechSynthesisTask(params_sm);

    Logger.debug("14.4. visualise data with url to the speechmarks file generated by the service");
    console.log(data);

    Logger.debug("14.5. OutputS3KeyPrefix used in s3-trigger");
    console.log("See regex for textTokenSpeechMarksJob in aws-ai-service/se-trigger/src/index.js");
    console.log(params_sm.OutputS3KeyPrefix);


}

const dynamoDbTableProvider = new DynamoDbTableProvider(JobAssignment);

const processTokenizedTextToSpeechJobResult = async (request) => {
    const workerJobHelper = new WorkerJobHelper(
        AIJob,
        dynamoDbTableProvider.table(request.tableName()),
        getAwsV4ResourceManager(request),
        request,
        request.input.jobAssignmentId
    );

    let jobAssignmentId = request.input.jobAssignmentId;
    
 
    try {
        await workerJobHelper.initialize();

        Logger.debug("14.6. Retrieve job inputParameters");
        let jobInput = workerJobHelper.getJobInput();

        Logger.debug("14.7. retrieve speechmarks");
        let s3Bucket = request.input.outputFile.awsS3Bucket;
        let s3Key = request.input.outputFile.awsS3Key;
        const speechmarks = await S3GetObject({ Bucket: s3Bucket, Key: s3Key });
        let speechmarks_json_a = "{ \"results\": { \"items\": [" + speechmarks.Body.toString().replace(/}/g, '},') + "]}}";
        let speechmarks_json_b = speechmarks_json_a.replace(/[\n]/g, "");
        let speechmarks_json = speechmarks_json_b.replace(',]' , ']');
        console.log(speechmarks_json);

        Logger.debug("14.8. copy speechmarks in speechmarks json file");
        let s3Bucket_sm = jobInput.outputLocation.awsS3Bucket;
        let s3Key_sm = jobInput.outputLocation.awsS3KeyPrefix + "speechmarks.json" ;
        let s3Params_sm = {
            Bucket: s3Bucket_sm,
            Key: s3Key_sm,
            Body: speechmarks_json
        }
        await S3PutObject(s3Params_sm);

        Logger.debug("14.9. retrieve stt_output_clean from TempBucket");
        const s3Bucket_stt = jobInput.inputFile.awsS3Bucket;
        const s3Key_stt = "stt/stt_output_clean.txt";
        let s3Object_stt;
        try {
            s3Object_stt = await S3GetObject({
                Bucket: s3Bucket_stt,
                Key: s3Key_stt,
            });
        } catch (error) {
            throw new Error("Unable to read file in bucket '" + s3Bucket_stt + "' with key '" + s3Key_stt + "' due to error: " + error.message);
        }

        Logger.debug("14.10. retrieve text from stt_output_clean.txt");
        const stt = s3Object_stt.Body.toString();
        console.log(stt);

        Logger.debug("14.11. parse stt output clean json data");
        let sttJsonData = JSON.parse(stt);
        console.log(sttJsonData);

        Logger.debug("14.12. parse speechmarks json data");
        let speechmarksJsonData = JSON.parse(speechmarks_json);
        console.log(speechmarksJsonData);

        Logger.debug("14.13. generate SSML file with breaks and translation sentences from speech marks and timings from stt");
        let ssldata ="<speak>"; 
        let k=0;
        // time reference expressed in milliseconds
        let t=0;

        for (var j = 0; j < sttJsonData.results.items.length; j++) {
            var item = sttJsonData.results.items[j];
            var punctuation = item.alternatives[0];
            var speechSpeedFactor = 1;
            var mediumBreakTimeFactor = 1.1;
            var longBreakTimeFactor = 1.3;
            var dotTime = 0.3;

            if (j === 0 & item.start_time > 0 ) {
                ssldata = ssldata + "<break time=\"" + item.start_time * mediumBreakTimeFactor + "s\"/>";
                // time in ms
                t = t + ((item.start_time * 1000) * mediumBreakTimeFactor);

            } else if ( item.type.includes("punctuation") & punctuation.content.includes(".") ) {
                if (j+1 < sttJsonData.results.items.length ){

                    if ((k+1 < speechmarksJsonData.results.items.length)) {

                        // var previousitem = sttJsonData.results.items[j - 1];
                        var lastitem = sttJsonData.results.items[j - 1];
                        var nextitem = sttJsonData.results.items[j + 1];
                        var speechmarksJsonDataItem = speechmarksJsonData.results.items[k];
                        var nextSpeechmarksJsonDataItem = speechmarksJsonData.results.items[k + 1];
                        var translatedSentenceDuration = (nextSpeechmarksJsonDataItem.time - speechmarksJsonDataItem.time) * speechSpeedFactor;
                        var endCurrentSentence = t + translatedSentenceDuration;
                        var breakTime = ((nextitem.start_time * 1000) - (lastitem.end_time*1000));

                        ssldata = ssldata  + speechmarksJsonDataItem.value.replace('.','<break time="0.3s"/>');

                        if (((nextitem.start_time * 1000) - (lastitem.end_time * 1000))<2500) {
                            ssldata = ssldata + "<break time=\"" + ((((nextitem.start_time * 1000) - (lastitem.end_time * 1000)) / 1000)) + "s\"/>";
                        } else if (((nextitem.start_time * 1000) - (lastitem.end_time * 1000))>=2500) {
                            ssldata = ssldata + "<break time=\"" + ((((nextitem.start_time * 1000) - (lastitem.end_time * 1000)) / 1000) * mediumBreakTimeFactor) + "s\"/>";
                        } else if (((nextitem.start_time * 1000) - (lastitem.end_time * 1000))>=5000) {
                            ssldata = ssldata + "<break time=\"" + ((((nextitem.start_time * 1000) - (lastitem.end_time * 1000)) / 1000) * longBreakTimeFactor) + "s\"/>";
                        }
                     } else if ((k+1 === speechmarksJsonData.results.items.length)) {
                        var speechmarksJsonDataItem = speechmarksJsonData.results.items[k];
                        ssldata = ssldata  + speechmarksJsonDataItem.value.replace('.','<break time="0.3s"/>');
                     }

                    k = k + 1;

                }
                // console.log(ssldata);
            }
        }
        ssldata=ssldata + "</speak>";

        Logger.debug("14.14. visualise SSML data");
        console.log(ssldata);


        Logger.debug("14.15. save ssml data into a ssml.txt file");
        let s3Bucket_ssml = jobInput.outputLocation.awsS3Bucket;
        let s3Key_ssml = jobInput.outputLocation.awsS3KeyPrefix + "ssml.txt";
        let s3Params_ssml = {
            Bucket: s3Bucket_ssml,
            Key: s3Key_ssml,
            Body: ssldata
        }
        await S3PutObject(s3Params_ssml);

        Logger.debug("14.16. updating JobAssignment with jobOutput -> ssml txt file");
        workerJobHelper.getJobOutput().outputFile = new Locator({
            awsS3Bucket: s3Bucket_ssml,
            awsS3Key: s3Key_ssml
        });
        
        await workerJobHelper.complete();


    } catch (error) {
        Logger.exception(error);
        try {
            await workerJobHelper.fail(error.message);
        } catch (error) {
            Logger.exception(error);
        }
    }


    Logger.debug("14.17. clean up service output file");
    try {
        await S3DeleteObject({
            Bucket: request.input.outputFile.awsS3Bucket,
            Key: request.input.outputFile.awsS3Key,
        });
    } catch (error) {
        console.warn("Failed to cleanup ssml translation output file");
    }

}

tokenizedTextToSpeech.profileName = "AWSTokenizedTextToSpeech";

module.exports = {
    tokenizedTextToSpeech,
    processTokenizedTextToSpeechJobResult
};