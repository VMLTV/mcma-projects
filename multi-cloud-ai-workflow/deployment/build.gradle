task generateTerraformTFVars {
    inputs.property("ENVIRONMENT_NAME", "${environmentName}")
    inputs.property("ENVIRONMENT_TYPE", "${environmentType}")
    inputs.property("AWS_ACCOUNT_ID", "${awsAccountId}")
    inputs.property("AWS_ACCESS_KEY", "${awsAccessKey}")
    inputs.property("AWS_SECRET_KEY", "${awsSecretKey}")
    inputs.property("AWS_REGION", "${awsRegion}")
    inputs.property("AWS_INSTANCE_TYPE", "${awsInstanceType}")
    inputs.property("AWS_INSTANCE_COUNT", "${awsInstanceCount}")

    inputs.property("AZURE_LOCATION", "${AzureLocation}")
    inputs.property("AZURE_ACCOUNT_ID", "${AzureAccountID}")
    inputs.property("AZURE_SUBSCRIPTION_ID", "${AzureSubscriptionKey}")
    inputs.property("AZURE_API_URL", "${AzureApiUrl}")

    inputs.property("GOOGLE_PROJECT_ID", "${googleProjectId}")
    inputs.property("GOOGLE_BUCKET_NAME", "${googleBucketName}")
    inputs.property("GOOGLE_CLIENT_EMAIL", "${googleClientEmail}")
    inputs.property("GOOGLE_PRIVATE_KEY", "${googlePrivateKey}")


    outputs.file("${projectDir}/terraform.tfvars")
    doLast {
        def targetFile = new File("${projectDir}/terraform.tfvars")
        targetFile.write("environment_name = \"${environmentName}\"\r\n")
        targetFile.append("environment_type = \"${environmentType}\"\r\n")
        targetFile.append("aws_account_id = \"${awsAccountId}\"\r\n")
        targetFile.append("aws_access_key = \"${awsAccessKey}\"\r\n")
        targetFile.append("aws_secret_key = \"${awsSecretKey}\"\r\n")
        targetFile.append("aws_region = \"${awsRegion}\"\r\n")
        targetFile.append("aws_instance_type = \"${awsInstanceType}\"\r\n")
        targetFile.append("aws_instance_count = \"${awsInstanceCount}\"\r\n")
        targetFile.append("upload_bucket = \"${environmentName}.${awsRegion}.${environmentType}.upload\"\r\n")
        targetFile.append("temp_bucket = \"${environmentName}.${awsRegion}.${environmentType}.temp\"\r\n")
        targetFile.append("repository_bucket = \"${environmentName}.${awsRegion}.${environmentType}.repository\"\r\n")
        targetFile.append("website_bucket = \"${environmentName}.${awsRegion}.${environmentType}.website\"\r\n")
        targetFile.append(("global_prefix = \"${environmentName}.${environmentType}\"\r\n").replace(".", "-"))
        targetFile.append("azure_location = \"${AzureLocation}\"\r\n")
        targetFile.append("azure_account_id = \"${AzureAccountID}\"\r\n")
        targetFile.append("azure_subscription_key = \"${AzureSubscriptionKey}\"\r\n")
        targetFile.append("azure_api_url = \"${AzureApiUrl}\"\r\n")
        targetFile.append("google_project_id = \"${googleProjectId}\"\r\n")
        targetFile.append("google_bucket_name = \"${googleBucketName}\"\r\n")
        targetFile.append("google_client_email = \"${googleClientEmail}\"\r\n")
        targetFile.append("google_private_key = \"${googlePrivateKey}\"\r\n")
    }
}

task generateTerraformWebsiteTF {
    dependsOn ":build";
    inputs.dir "../website/dist"
    outputs.file "${projectDir}/storage/website.tf"

    doLast {
        def idx = 1;
        def targetFile = new File("${projectDir}/storage/website.tf");
        targetFile.text = ""

        fileTree(dir: "../website/dist/website").visit {f -> 
            if (f.getFile().isFile()) {
                def mimeType = ""
                if (f.path.endsWith(".html")) {
                    mimeType = "text/html"
                } else if (f.path.endsWith(".css")) {
                    mimeType = "text/css"
                } else if (f.path.endsWith(".js")) {
                    mimeType = "application/javascript"
                } else if (f.path.endsWith(".json")) {
                    mimeType = "application/json"
                } else if (f.path.endsWith(".ico")) {
                    mimeType = "image/x-icon"
                } else if (f.path.endsWith(".txt")) {
                    mimeType = "text/plain"
                } else if (f.path.endsWith(".svg")) {
                    mimeType = "image/svg+xml"
                }

                targetFile.append("resource \"aws_s3_bucket_object\" \"file_" + idx++ + "\" {\r\n" )
                targetFile.append("  bucket       = \"\${aws_s3_bucket.website.bucket}\"\r\n")
                targetFile.append("  key          = \"" + f.relativePath + "\"\r\n")
                targetFile.append("  source       = \"" + f.file.path.replace("\\", "/") + "\"\r\n")
                targetFile.append("  content_type = \"" + mimeType + "\"\r\n")
                targetFile.append("  etag         = \"\${filemd5(\"" + f.file.path.replace("\\", "/") + "\")}\"\r\n")
                targetFile.append("}\r\n\r\n")
            }
        }
    }
}

task generateAwsCredentialsJson {
    inputs.property("AWS_ACCESS_KEY", "${awsAccessKey}")
    inputs.property("AWS_SECRET_KEY", "${awsSecretKey}")
    inputs.property("AWS_REGION", "${awsRegion}")
    outputs.file("${projectDir}/aws-credentials.json")
    doLast {
        def targetFile = new File("${projectDir}/aws-credentials.json")
        targetFile.write("{\r\n")
        targetFile.append("    \"accessKeyId\": \"${awsAccessKey}\",\r\n")
        targetFile.append("    \"secretAccessKey\": \"${awsSecretKey}\",\r\n")
        targetFile.append("    \"region\": \"${awsRegion}\"\r\n")
        targetFile.append("}\r\n")
    }
}

task terraformInit(type: Exec) {
    inputs.file "main.tf"
    outputs.upToDateWhen { file(".terraform").exists() }
    commandLine terraformExecutable
    args "init"
}

task terraformPlan(type: Exec) {
    dependsOn ":build"
    dependsOn terraformInit
    dependsOn generateTerraformTFVars
    dependsOn generateTerraformWebsiteTF
    commandLine terraformExecutable
    args "plan"
}

task terraformApply(type: Exec) {
    dependsOn ":build"
    dependsOn terraformInit
    dependsOn generateTerraformTFVars
    dependsOn generateTerraformWebsiteTF
    commandLine terraformExecutable
    args "apply", "-auto-approve"
}

task terraformDestroy(type: Exec) {
    dependsOn terraformInit
    dependsOn generateTerraformTFVars
    dependsOn generateTerraformWebsiteTF
    commandLine terraformExecutable
    args "destroy", "-force"
}

task terraformOutput(type: Exec) {
    mustRunAfter terraformApply
    inputs.file("terraform.tfstate")
    outputs.file("terraform.output")
    commandLine terraformExecutable
    args "output"
    doFirst {
        standardOutput new FileOutputStream("${projectDir}/terraform.output")
    }
}

task updateServiceRegistry(type: Exec) {
    dependsOn generateAwsCredentialsJson
    dependsOn terraformOutput
    dependsOn "registry:npmInstall"
    inputs.file("${projectDir}/terraform.output")
    inputs.file("${projectDir}/registry/src/index.js")
    inputs.file("${projectDir}/registry/package.json")
    outputs.upToDateWhen { true }
    commandLine nodeExecutable
    args "registry/src/index.js"
    doFirst {
        standardInput new FileInputStream("${projectDir}/terraform.output")
    }
}

clean {
    delete "${projectDir}/terraform.output"
    delete "${projectDir}/storage/website.tf"
}

task plan {}
plan.dependsOn(terraformPlan)

task deploy {}
deploy.dependsOn(terraformApply)
deploy.dependsOn(updateServiceRegistry)

task destroy {}
destroy.dependsOn(terraformDestroy)
destroy.dependsOn(clean)

task terraformTaintJobRepository(type: Exec) {
    commandLine terraformExecutable
    args "taint", "module.services.aws_api_gateway_deployment.job_repository_deployment"
}

task terraformTaintServiceRegistry(type: Exec) {
    commandLine terraformExecutable
    args "taint", "module.services.aws_api_gateway_deployment.service_registry_deployment"
}

task terraformTaintMediaRepository(type: Exec) {
    commandLine terraformExecutable
    args "taint", "module.services.aws_api_gateway_deployment.media_repository_deployment"
}

task terraformTaint
terraformTaint.dependsOn(terraformTaintJobRepository)
terraformTaint.dependsOn(terraformTaintServiceRegistry)
terraformTaint.dependsOn(terraformTaintMediaRepository)
