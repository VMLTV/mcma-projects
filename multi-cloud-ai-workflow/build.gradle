import groovy.json.JsonOutput
import groovy.json.JsonSlurper

def McmaVersion = "0.9.0"

def requiredVersionTerraform = "0.12.19"
def requiredVersionNodeJS = "10.16.3"
def requiredVersionTsc = "3.7.2"

if (!hasProperty("AzureLocation")) {
    ext.AzureLocation = "trial"
}
if (!hasProperty("AzureAccountID")) {
    ext.AzureAccountID = "undefined"
}
if (!hasProperty("AzureSubscriptionKey")) {
    ext.AzureSubscriptionKey = "undefined"
}
if (!hasProperty("AzureApiUrl")) {
    ext.AzureApiUrl = "https://api.videoindexer.ai"
}

if (!hasProperty("GoogleServiceCredentialsFile")) {
    ext.GoogleServiceCredentialsFile = "undefined"
}
if (!hasProperty("GoogleBucketName")) {
    ext.GoogleBucketName = "undefined"
}

if (!hasProperty("EnableECS")) {
    ext.EnableECS = "true"
}

def googleServiceCredentialsFile = file(ext.GoogleServiceCredentialsFile).path

def isVersionGreaterThanOrEqualTo(expected, actual) {
    def expectedParts = expected.split(/\./);   
    def actualParts = actual.split(/\./);

    for (int i = 0; i < actualParts.length; i++) {
        if (i >= expectedParts.length || expectedParts[i].toInteger() < actualParts[i].toInteger()) {
            return false;
        }
    }

    return true;
}

allprojects {
    ext.GoogleServiceCredentialsFile = googleServiceCredentialsFile

    ext {
        if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            nodeExecutable = ["node"]
            ngExecutable = ["cmd", "/c", "ng"]
            npmExecutable = ["cmd", "/c", "npm"]
            terraformExecutable = ["cmd", "/c", "terraform"]
            tscExecutable = ["cmd", "/c", "tsc"]
        } else {
            nodeExecutable = ["node"]
            ngExecutable = ["ng"]
            npmExecutable = ["npm"]
            terraformExecutable = ["terraform"]
            tscExecutable = ["tsc"]
        }

        awsAvailableLibraries = [".bin", "aws-sdk", "buffer", "dynamodb-doc", "events", "ieee754", "jmespath", "lodash", "punycode", "querystring", "url"]
    }
}

def getVersionNodeJS = { ->
    def stdout = new ByteArrayOutputStream()
    def stderr = new ByteArrayOutputStream()
    try {
        exec {
            commandLine nodeExecutable
            args "--version"
            standardOutput stdout
            errorOutput stderr
        }
    } catch (Exception ignored) {
    }

    return stdout.toString().trim().replace("v", "")
}

task verifyNodeJS {
    inputs.property("VERSION_NODE_JS", requiredVersionNodeJS)
    outputs.upToDateWhen { getVersionNodeJS() == requiredVersionNodeJS }
    doLast {
        if (getVersionNodeJS() != requiredVersionNodeJS) {
            throw new Exception("Required Node version " + requiredVersionNodeJS + " not installed")
        }
    }
}

def getVersionTerraform = { ->
    def stdout = new ByteArrayOutputStream()
    def stderr = new ByteArrayOutputStream()
    try {
        exec {
            commandLine terraformExecutable
            args "--version"
            standardOutput stdout
            errorOutput stderr
        }
    } catch (Exception ignored) {
    }

    return stdout.toString().split("\n")[0].trim().replace("Terraform v", "")
}

task verifyTerraform {
    inputs.property("VERSION_TERRAFORM", requiredVersionTerraform)
    outputs.upToDateWhen { getVersionTerraform() == requiredVersionTerraform }
    doLast {
        if (getVersionTerraform() != requiredVersionTerraform) {
            throw new Exception("Required Terraform version " + requiredVersionTerraform + " not available")
        }
    }
}

def getVersionTsc = { ->
    def stdout = new ByteArrayOutputStream()
    def stderr = new ByteArrayOutputStream()
    try {
        exec {
            commandLine tscExecutable
            args "-v"
            standardOutput stdout
            errorOutput stderr
        }
    } catch (Exception ignored) {
    }

    return stdout.toString().trim().replace("Version ", "")
}

task verifyTsc {
    inputs.property("VERSION_TSC", requiredVersionTsc)
    outputs.upToDateWhen { isVersionGreaterThanOrEqualTo(getVersionTsc(), requiredVersionTsc) }
    doLast {
        def versionTsc = getVersionTsc()
        if (!isVersionGreaterThanOrEqualTo(versionTsc, requiredVersionTsc)) {
            throw new Exception("tsc version must be at least " + requiredVersionTsc + ". Detected version " + versionTsc)
        }
    }
}

task build {
    dependsOn "services:build"
    dependsOn "workflows:build"
    dependsOn "website:build"
}

task clean {}

subprojects {
    task setMcmaVersion {
        def packageJson = file("package.json")

        enabled packageJson.exists()
        inputs.file(packageJson)
        inputs.property("VERSION", McmaVersion)
        outputs.file(packageJson)

        doLast {
            def jsonSlurper = new JsonSlurper()
            def object = jsonSlurper.parse(file("package.json"))

            if (object.dependencies != null) {
                object.dependencies.keySet().each {
                    object.dependencies[it] = it.startsWith("@mcma/") ? McmaVersion : object.dependencies[it]
                }
            }
            if (object.peerDependencies != null) {
                object.peerDependencies.keySet().each {
                    object.peerDependencies[it] = it.startsWith("@mcma/") ? McmaVersion : object.peerDependencies[it]
                }
            }
            if (object.devDependencies != null) {
                object.devDependencies.keySet().each {
                    object.devDependencies[it] = it.startsWith("@mcma/") ? McmaVersion : object.devDependencies[it]
                }
            }

            def json = JsonOutput.toJson(object)
            def jsonPretty = JsonOutput.prettyPrint(json) + "\n"

            packageJson.write(jsonPretty)
        }
    }

    task npmInstall(type: Exec) {
        dependsOn verifyNodeJS
        enabled file("package.json").exists()
        inputs.file("package.json")
        outputs.file("package-lock.json")
        outputs.dir("node_modules")
        commandLine npmExecutable
        args "install"
    }

    task npmUpdate(type: Exec) {
        dependsOn verifyNodeJS
        enabled file("package.json").exists()
        inputs.file "package.json"
        inputs.property("todaysDate", new Date().clearTime())
        outputs.upToDateWhen { true }
        commandLine npmExecutable
        args "update"
    }

    task npmDedup(type: Exec) {
        dependsOn verifyNodeJS
        enabled file("package.json").exists()
        inputs.file("package.json")
        outputs.file("package-lock.json")
        outputs.dir("node_modules")
        commandLine npmExecutable
        args "dedup"
    }

    task clean(type: Delete) {
        delete "build"
        delete "dist"
        delete "node_modules"
    }

    task tsc(type: Exec) {
        dependsOn npmInstall
        dependsOn verifyNodeJS
        dependsOn verifyTsc
        enabled file("tsconfig.json").exists()
        enabled file("package.json").exists()
        inputs.dir("src")
        inputs.file("tsconfig.json")
        inputs.file("package.json")
        outputs.dir("build/staging")
        commandLine tscExecutable
    }
}

afterEvaluate {
    // avoiding simultaneous connections to npmjs.com
    def prevTask = null
    project.subprojects.each {
        def task = it.tasks.find { task -> task.name.contains('npmUpdate') }
        if (task != null) {
            if (prevTask != null) {
                task.mustRunAfter(prevTask)
            }
            prevTask = task
        }
    }

    prevTask = null
    project.subprojects.each {
        def task = it.tasks.find { task -> task.name.contains('npmInstall') }
        if (task != null) {
            if (prevTask != null) {
                task.mustRunAfter(prevTask)
            }
            prevTask = task
        }
    }
}

